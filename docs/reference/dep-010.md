+++
dep = 10
title = "Draft Hierarchy and Dependency Support (Multiple container support)"
authors = [ "Dan Mikita <danmikita@gmail.com>" ]
created = 2018-07-05
+++

# Abstract
Many projects require multiple container images to be built and deployed together either in the same pod or as a separate service all together. These images deploy using one to many Helm charts.

# Specification
There are two major use cases that have very different technical implementations:

## Use Case 1
### A project that creates multiple docker images deployed using a single Helm chart.
(This use case also supports multiple containers per pod.)

The parent directoy of your project would have a draft.toml which would have a new section called `global` and several new nodes. For example, in the following project structure:

```
myapp/
  draft.toml
  chart/
    java/
      Chart.yaml
      templates/
      deployment.yaml
      service.yaml
      values.yaml
  module-1/
    Dockerfile
    src/
    target/
      app-1.jar
    pom.xml
    draft.toml
  module-2/
    Dockerfile
    src/
    target/
      app-2.jar
    pom.xml
    draft.toml
```

The parent `draft.toml` would look something like this:
```
[global]
releasename = "my-app"
modules = ["module-1/draft.toml", "module-2/draft.toml"]
chart = "charts/java"
set = ["foo=bar", "car=star"]
watch = false
```

While the child `draft.toml` would look like what we are used to:
```
[environments]
    [environments.development]
    name = "module1"
    registry = "microsoft"
    wait = true
    watch-delay = 1
    override-ports = ["8080:8080", "9229:9229"]
    auto-connect = false
    custom-tags = ["backend-dev"]
    dockerfile = "Dockerfile.dev"
```

The `.Values.image.repository` and `.Values.image.tag` would need to be manually modified by the developer using the `name` from the sub-module's `draft.toml`. Which would affect the injected image values to be:

*deployment.yaml*
```
spec:
  containers:
  - name: {{ .Chart.Name }}
    image: "{{ .Values.image.module1.repository }}:{{ .Values.image.module1.tag }}"
```


## Use Case 2
### A project that creates multiple docker images deployed using separate Helm charts.

The parent directoy of your project would have a `draft.toml` which would have a new section called `global`. For example, in the following project structure:

```
myapp/
  draft.toml
  module-1/
    chart/
      java/
        Chart.yaml
        templates/
        deployment.yaml
        service.yaml
        values.yaml
    Dockerfile
    src/
    target/
      app-1.jar
    pom.xml
    draft.toml
  module-2/
    chart/
      java/
        Chart.yaml
        templates/
        deployment.yaml
        service.yaml
        values.yaml
    Dockerfile
    src/
    target/
      app-2.jar
    pom.xml
    draft.toml
```

The parent draft.toml would look something like this:
```
[global]
modules = ["module-1/draft.toml", "module-2/draft.toml"]
```

While the child draft.toml would look like what we are used to:
```
[environments]
    [environments.development]
    name = "module1"
    registry = "microsoft"
    set = ["foo=bar", "car=star"]
    wait = true
    watch = false
    watch-delay = 1
    override-ports = ["8080:8080", "9229:9229"]
    auto-connect = false
    custom-tags = ["backend-dev"]
    chart = "charts/my-app-dev"
    dockerfile = "Dockerfile.dev"
```

In this case, the `.Values.image.repository` and `.Values.image.tag` would not need to be modified in the `deployment.yaml`.

## Image building
The idea is that the `modules` node would instruct draft to basically do the image building portion it is already doing but in multiple places. I still have questions of whether this should be done synchronously or asynchronously based upon whether the Docker daemon would support it.

# Motivation
There are many projects that have multiple configurations and images that are necessary for a deployment to function properly. As of today - draft only supports a single image build and single Helm chart (excluding the `requirements.yaml`). By adding this funtionality we would be one step closer to a draft that supports all the various use-cases of Helm charts.

# Rationale
The rationale behind this design is to support backwards compatability as much as possible, and to support as many various project configurations as possible. This design could also allow for nested modules by including a `global` setting in a child module as well which would allow for even more complex project layouts.

By introducing a `global` section in the draft.toml we are also setting up for future features as well as leaving existing draft functionality alone.

# Backwards Compatibility


# Reference Implementation
